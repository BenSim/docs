(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4505],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return u},kt:function(){return h}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(t),h=o,m=p["".concat(c,".").concat(h)]||p[h]||d[h]||a;return t?r.createElement(m,i(i({ref:n},u),{},{components:t})):r.createElement(m,i({ref:n},u))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},3620:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return p}});var r=t(2122),o=t(9756),a=(t(7294),t(3905)),i=["components"],s={title:"CW20 ICS20",sidebar_position:4},c="CW20 ICS20",l={unversionedId:"ibc/cw20-ics20",id:"version-0.14/ibc/cw20-ics20",isDocsHomePage:!1,title:"CW20 ICS20",description:"Specification",source:"@site/versioned_docs/version-0.14/ibc/cw20-ics20.md",sourceDirName:"ibc",slug:"/ibc/cw20-ics20",permalink:"/0.14/ibc/cw20-ics20",editUrl:"https://github.com/CosmWasm/docs/edit/main/versioned_docs/version-0.14/ibc/cw20-ics20.md",version:"0.14",sidebarPosition:4,frontMatter:{title:"CW20 ICS20",sidebar_position:4}},u=[{value:"Specification",id:"specification",children:[{value:"Workflow",id:"workflow",children:[]},{value:"Messages",id:"messages",children:[]},{value:"Queries",id:"queries",children:[]},{value:"IBC Responses",id:"ibc-responses",children:[]}]},{value:"Demonstration",id:"demonstration",children:[]}],d={toc:u};function p(e){var n=e.components,t=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"cw20-ics20"},"CW20 ICS20"),(0,a.kt)("h2",{id:"specification"},"Specification"),(0,a.kt)("p",null,"This is an ",(0,a.kt)("em",{parentName:"p"},"IBC Enabled")," contract that allows us to send CW20 tokens from one chain over the standard ICS20\nprotocol to the bank module of another chain. In short, it let's us send our custom CW20 tokens with IBC and use\nthem just like native tokens on other chains."),(0,a.kt)("p",null,"It is only designed to send tokens and redeem previously sent tokens. It will not mint tokens belonging\nto assets originating on the foreign chain. This is different than the Golang ",(0,a.kt)("inlineCode",{parentName:"p"},"ibctransfer")," module, but\nwe properly implement ICS20 and respond with an error message... let's hope the Go side handles this correctly."),(0,a.kt)("h3",{id:"workflow"},"Workflow"),(0,a.kt)("p",null,"The contract starts with minimal state. It just stores a default timeout in seconds for all packets it sends.\nMost importantly it binds a local IBC port to enable channel connections."),(0,a.kt)("p",null,"An external party first needs to make one or more channels using this contract as one endpoint. It will use standard ics20\nunordered channels for the version negotiation. Once established, it manages a list of known channels. You can use\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/confio/ts-relayer"},"ts-relayer")," ",(0,a.kt)("inlineCode",{parentName:"p"},"ibc-setup ics20")," command to create these."),(0,a.kt)("p",null,"After there is at least one channel, you can send any CW20 token to this contract via the\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm-plus/blob/master/packages/cw20/README.md#receiver"},"receiver pattern"),".\nThe receive message must contain the channel to send over and the remote address to send to. It may optionally\ninclude a custom timeout."),(0,a.kt)("h3",{id:"messages"},"Messages"),(0,a.kt)("p",null,"It only accepts CW20ReceiveMsg from a cw20 contract. The data sent along with that message must be a JSON-serialized\nTransferMsg:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct TransferMsg {\n    /// The local channel to send the packets on\n    pub channel: String,\n    /// The remote address to send to\n    /// Don't use HumanAddress as this will likely have a different Bech32 prefix than we use\n    /// and cannot be validated locally\n    pub remote_address: String,\n    /// How long the packet lives in seconds. If not specified, use default_timeout\n    pub timeout: Option<u64>,\n}\n")),(0,a.kt)("p",null,"In addition, it supports directly sending native tokens via ",(0,a.kt)("inlineCode",{parentName:"p"},"ExecuteMsg::Transfer(TransferMsg)"),".\nYou must send ",(0,a.kt)("em",{parentName:"p"},"exactly one")," coin denom along with the transfer message, and that amount will be transfered\nto the remote host."),(0,a.kt)("h3",{id:"queries"},"Queries"),(0,a.kt)("p",null,"Queries only make sense relative to the established channels of this contract."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Port{}")," - returns the port ID this contract has bound, so you can create channels. This info can be queried\nvia wasmd contract info query, but we expose another query here for convenience."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ListChannels{}")," - returns a (currently unpaginated) list of all channels that have been created on this contract.\nReturns their local channelId along with some basic metadata, like the remote port/channel and the connection they\nrun on top of."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Channel{id}")," - returns more detailed information on one specific channel. In addition to the information available\nin the list view, it returns the current outstanding balance on that channel, as well as the total amount that\nhas ever been sent on the channel.")),(0,a.kt)("h3",{id:"ibc-responses"},"IBC Responses"),(0,a.kt)("p",null,"These are defined by the ICS20 spec."),(0,a.kt)("p",null,"Notably, each Channel has a balance of tokens sent over that channel. If an incoming transfer request comes in for\na denom it does not know, or for a balance larger than we have sent, we will return an error in the acknowledgement\npacket."),(0,a.kt)("h2",{id:"demonstration"},"Demonstration"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Under Development")))}p.isMDXComponent=!0}}]);